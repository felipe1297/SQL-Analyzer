{
    "no_db_access": {
        "NDB001": {
            "description": "‚ö†Ô∏è Selecting all columns can be inefficient and lead to excessive data retrieval.",
            "recommendation": "üí° Select only the necessary columns.",
            "example": {
                "bad": "SELECT * FROM users;",
                "good": "SELECT id, name FROM users;"
            }
        },
        "NDB002": {
            "description": "‚ö†Ô∏è Nested subqueries can be inefficient and hard to read.",
            "recommendation": "üí° Use JOINs when possible.",
            "example": {
                "bad": "SELECT * FROM (SELECT * FROM orders WHERE amount > 100) AS sub;",
                "good": "SELECT orders.id, orders.amount FROM orders WHERE orders.amount > 100;"
            }
        },
        "NDB003": {
            "description": "‚ö†Ô∏è Performing a JOIN without a condition can result in a Cartesian product.",
            "recommendation": "üí° Ensure each JOIN has a proper join condition.",
            "example": {
                "bad": "SELECT * FROM users, orders;",
                "good": "SELECT users.name, orders.amount FROM users JOIN orders ON users.id = orders.user_id;"
            }
        },
        "NDB004": {
            "description": "‚ö†Ô∏è Applying functions to columns in the WHERE clauses can prevent index usage.",
            "recommendation": "üí° Avoid using functions in WHERE clauses.",
            "example": {
                "bad": "SELECT * FROM users WHERE UPPER(name) = 'JOHN';",
                "good": "SELECT * FROM users WHERE name = 'John';"
            }
        },
        "NDB005": {
            "description": "‚ö†Ô∏è Conditions that are always false or true, making the query nonsensical.",
            "recommendation": "üí° Review the logic of the conditions.",
            "example": {
                "bad": "SELECT * FROM users WHERE 1 = 0;",
                "good": "SELECT * FROM users WHERE active = true;"
            }
        },
        "NDB006": {
            "description": "‚ö†Ô∏è Using DISTINCT to hide duplicate issues instead of addressing the root cause.",
            "recommendation": "üí° Investigate and solve the cause of duplicates.",
            "example": {
                "bad": "SELECT DISTINCT name FROM users;",
                "good": "SELECT name FROM users GROUP BY name HAVING COUNT(*) = 1;"
            }
        },
        "NDB007": {
            "description": "‚ö†Ô∏è Excessive use of OR can prevent effective use of indexes.",
            "recommendation": "üí° Consider rewriting the query using UNION or improving the logic.",
            "example": {
                "bad": "SELECT * FROM users WHERE name = 'John' OR name = 'Jane';",
                "good": "SELECT * FROM users WHERE name IN ('John', 'Jane');"
            }
        },
        "NDB008": {
            "description": "‚ö†Ô∏è Using aggregate functions without a GROUP BY clause can lead to unexpected results.",
            "recommendation": "üí° Ensure aggregate functions have an appropriate GROUP BY clause.",
            "example": {
                "bad": "SELECT COUNT(*), name FROM users;",
                "good": "SELECT COUNT(*), name FROM users GROUP BY name;"
            }
        },
        "NDB009": {
            "description": "‚ö†Ô∏è OFFSET without LIMIT can lead to retrieving large amounts of unnecessary data.",
            "recommendation": "üí° Always use LIMIT with OFFSET.",
            "example": {
                "bad": "SELECT * FROM users OFFSET 10;",
                "good": "SELECT * FROM users LIMIT 10 OFFSET 10;"
            }
        },
        "NDB010": {
            "description": "‚ö†Ô∏è Using unclear or unnecessary aliases can make the code harder to read.",
            "recommendation": "üí° Use clear aliases only when necessary.",
            "example": {
                "bad": "SELECT u.name FROM users u;",
                "good": "SELECT users.name FROM users;"
            }
        }
    },
    "db_access": {
        "DB001": {
            "description": "‚ö†Ô∏è Lack of indexes on columns used in JOINs can lead to performance degradation.",
            "recommendation": "üí° Create indexes on columns used in JOINs.",
            "example": {
                "bad": "SELECT users.name, orders.amount FROM users JOIN orders ON users.id = orders.user_id;",
                "good": "CREATE INDEX idx_users_id ON users(id);"
            }
        },
        "DB002": {
            "description": "‚ö†Ô∏è Lack of indexes on columns used in WHERE clauses can lead to full table scans.",
            "recommendation": "üí° Create indexes on columns used in WHERE clauses.",
            "example": {
                "bad": "SELECT * FROM users WHERE name = 'John';",
                "good": "CREATE INDEX idx_users_name ON users(name);"
            }
        }
    }
}