{
    "no_db_access": {
        "NDB001": {
            "description": "‚ö†Ô∏è Selecting all columns can be inefficient and lead to excessive data retrieval.",
            "recommendation": "üí° Select only the necessary columns.",
            "example": {
                "bad": "SELECT * FROM users;",
                "good": "SELECT id, name FROM users;"
            }
        },
        "NDB002": {
            "description": "‚ö†Ô∏è Nested subqueries can be inefficient and hard to read.",
            "recommendation": "üí° Use JOINs when possible.",
            "example": {
                "bad": "SELECT * FROM (SELECT * FROM orders WHERE amount > 100) AS sub;",
                "good": "SELECT orders.id, orders.amount FROM orders WHERE orders.amount > 100;"
            }
        },
        "NDB003": {
            "description": "‚ö†Ô∏è Performing a JOIN without a condition can result in a Cartesian product.",
            "recommendation": "üí° Ensure each JOIN has a proper join condition.",
            "example": {
                "bad": "SELECT * FROM users, orders;",
                "good": "SELECT users.name, orders.amount FROM users JOIN orders ON users.id = orders.user_id;"
            }
        },
        "NDB004": {
            "description": "‚ö†Ô∏è Applying functions to columns in the WHERE clauses can prevent index usage.",
            "recommendation": "üí° Avoid using functions in WHERE clauses.",
            "example": {
                "bad": "SELECT * FROM users WHERE UPPER(name) = 'JOHN';",
                "good": "SELECT * FROM users WHERE name = 'John';"
            }
        },
        "NDB005": {
            "description": "‚ö†Ô∏è Conditions that are always false or true, making the query nonsensical.",
            "recommendation": "üí° Review the logic of the conditions.",
            "example": {
                "bad": "SELECT * FROM users WHERE 1 = 0;",
                "good": "SELECT * FROM users WHERE active = true;"
            }
        },
        "NDB006": {
            "description": "‚ö†Ô∏è Using DISTINCT to hide duplicate issues instead of addressing the root cause.",
            "recommendation": "üí° Investigate and solve the cause of duplicates.",
            "example": {
                "bad": "SELECT DISTINCT name FROM users;",
                "good": "SELECT name FROM users GROUP BY name HAVING COUNT(*) = 1;"
            }
        },
        "NDB007": {
            "description": "‚ö†Ô∏è Excessive use of OR can prevent effective use of indexes.",
            "recommendation": "üí° Consider rewriting the query using UNION or improving the logic.",
            "example": {
                "bad": "SELECT * FROM users WHERE name = 'John' OR name = 'Jane';",
                "good": "SELECT * FROM users WHERE name IN ('John', 'Jane');"
            }
        },
        "NDB008": {
            "description": "‚ö†Ô∏è Using aggregate functions without a GROUP BY clause can lead to unexpected results.",
            "recommendation": "üí° Ensure aggregate functions have an appropriate GROUP BY clause.",
            "example": {
                "bad": "SELECT COUNT(*), name FROM users;",
                "good": "SELECT COUNT(*), name FROM users GROUP BY name;"
            }
        },
        "NDB009": {
            "description": "‚ö†Ô∏è OFFSET without LIMIT can lead to retrieving large amounts of unnecessary data.",
            "recommendation": "üí° Always use LIMIT with OFFSET.",
            "example": {
                "bad": "SELECT * FROM users OFFSET 10;",
                "good": "SELECT * FROM users LIMIT 10 OFFSET 10;"
            }
        },
        "NDB010": {
            "description": "‚ö†Ô∏è Using unclear or unnecessary aliases can make the code harder to read.",
            "recommendation": "üí° Use clear aliases only when necessary.",
            "example": {
                "bad": "SELECT u.name FROM users u;",
                "good": "SELECT users.name FROM users;"
            }
        }
    },
    "db_access": {
        "DB001": {
            "description": "‚ö†Ô∏è Lack of indexes on columns used in JOINs can lead to performance degradation.",
            "recommendation": "üí° Create indexes on columns used in JOINs.",
            "example": {
                "bad": "SELECT users.name, orders.amount FROM users JOIN orders ON users.id = orders.user_id;",
                "good": "CREATE INDEX idx_users_id ON users(id);"
            }
        },
        "DB002": {
            "description": "‚ö†Ô∏è Lack of indexes on columns used in WHERE clauses can lead to full table scans.",
            "recommendation": "üí° Create indexes on columns used in WHERE clauses.",
            "example": {
                "bad": "SELECT * FROM users WHERE name = 'John';",
                "good": "CREATE INDEX idx_users_name ON users(name);"
            }
        },
        "DB003": {
            "description": "‚ö†Ô∏è Tables with too many columns can be hard to manage and optimize.",
            "recommendation": "üí° Review the database normalization.",
            "example": {
                "bad": "CREATE TABLE users (id INT, name VARCHAR(255), age INT, address VARCHAR(255), phone VARCHAR(20), email VARCHAR(255), ...);",
                "good": "CREATE TABLE users (id INT, name VARCHAR(255));"
            }
        },
        "DB004": {
            "description": "‚ö†Ô∏è Tables without primary keys can lead to data integrity and performance issues.",
            "recommendation": "üí° Ensure each table has a primary key.",
            "example": {
                "bad": "CREATE TABLE users (name VARCHAR(255), age INT);",
                "good": "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255));"
            }
        },
        "DB005": {
            "description": "‚ö†Ô∏è Indexes that are never used can lead to wasted resources.",
            "recommendation": "üí° Review and drop unnecessary indexes.",
            "example": {
                "bad": "CREATE INDEX idx_unused ON users(age);",
                "good": "DROP INDEX idx_unused;"
            }
        },
        "DB006": {
            "description": "‚ö†Ô∏è Queries that can lead to deadlocks in the database.",
            "recommendation": "üí° Review and optimize transactions to avoid deadlocks.",
            "example": {
                "bad": "BEGIN; UPDATE users SET name = 'John' WHERE id = 1; UPDATE orders SET amount = 100 WHERE user_id = 1; COMMIT;",
                "good": "BEGIN; UPDATE orders SET amount = 100 WHERE user_id = 1; UPDATE users SET name = 'John' WHERE id = 1; COMMIT;"
            }
        },
        "DB007": {
            "description": "‚ö†Ô∏è Indexes on columns with few unique values may not be effective and can increase maintenance costs.",
            "recommendation": "üí° Evaluate the need for indexes on low cardinality columns.",
            "example": {
                "bad": "CREATE INDEX idx_gender ON users(gender);",
                "good": "DROP INDEX idx_gender;"
            }
        },
        "DB008": {
            "description": "‚ö†Ô∏è Selecting large text columns unnecessarily can impact performance.",
            "recommendation": "üí° Select large text columns only when needed.",
            "example": {
                "bad": "SELECT bio FROM users;",
                "good": "SELECT bio FROM users WHERE id = 1;"
            }
        },
        "DB009": {
            "description": "‚ö†Ô∏è Queries on large tables without LIMIT clauses can lead to long response times.",
            "recommendation": "üí° Use LIMIT in queries on large tables to improve performance.",
            "example": {
                "bad": "SELECT * FROM users;",
                "good": "SELECT * FROM users LIMIT 100;"
            }
        },
        "DB010": {
            "description": "‚ö†Ô∏è Very large tables without partitioning can affect performance.",
            "recommendation": "üí° Implement partitioning on large tables for query efficiency.",
            "example": {
                "bad": "CREATE TABLE orders (id INT, amount DECIMAL(10, 2), order_date DATE);",
                "good": "CREATE TABLE orders (id INT, amount DECIMAL(10, 2), order_date DATE) PARTITION BY RANGE (order_date);"
            }
        },
        "DB011": {
            "description": "‚ö†Ô∏è Temporary data that is not cleaned up can grow uncontrollably and affect performance.",
            "recommendation": "üí° Implement cleanup mechanisms for temporary data.",
            "example": {
                "bad": "CREATE TEMP TABLE temp_data AS SELECT * FROM users;",
                "good": "CREATE TEMP TABLE temp_data AS SELECT * FROM users; DROP TABLE temp_data;"
            }
        },
        "DB012": {
            "description": "‚ö†Ô∏è Lack of consistency in foreign key relationships can lead to referential integrity issues.",
            "recommendation": "üí° Review and maintain consistent foreign key relationships.",
            "example": {
                "bad": "CREATE TABLE orders (id INT, user_id INT);",
                "good": "CREATE TABLE orders (id INT, user_id INT, CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id));"
            }
        }
    }
}